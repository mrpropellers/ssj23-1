// Based on SplineMesh.ExampleGrowingRoot

using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using SplineMesh;

namespace LeftOut.GameJam.Bonsai
{
    [RequireComponent(typeof(Spline))]
    [ExecuteAlways]
    public class GrowingTreeLimb : MonoBehaviour
    {
        GameObject m_Generated;
        Spline m_Spline;
        MeshBender m_MeshBender;
        float m_GrowthProgress;
        [SerializeField]
        Mesh m_Mesh;

        [SerializeField]
        Material m_Material;

        [SerializeField]
        Vector3 m_MeshRotation;

        [SerializeField]
        Vector3 m_MeshScale;

        [SerializeField]
        float m_StartScale = 1f;

        internal List<GrowingTreeLimb> Branches { get; private set; }
        internal bool IsInitialized { get; private set; }
        internal bool IsCurrentlyGrowing { get; private set; }
        internal bool IsFullyGrown => Mathf.Approximately(m_GrowthProgress, 1f);
        internal float CurrentGrowthDistance => m_Spline.Length * m_GrowthProgress;

        void Awake()
        {
            Init();
        }

        internal void Init()
        {
            Debug.Log("Initializing trunk.");
            IsCurrentlyGrowing = false;
            if (Branches is { Count: > 0 })
            {
                Debug.LogWarning($"{name} has active Branches - you'll need to manually delete them.");
            }
            Branches = new List<GrowingTreeLimb>();
            m_GrowthProgress = 0f;
            var generatedName = "generated by " + GetType().Name;
            var generatedTransform = transform.Find(generatedName);
            m_Generated = generatedTransform != null
                ? generatedTransform.gameObject
                : UOUtility.Create(generatedName, gameObject,
                    typeof(MeshFilter),
                    typeof(MeshRenderer),
                    typeof(MeshBender));

            m_Generated.GetComponent<MeshRenderer>().material = m_Material;

            m_MeshBender = m_Generated.GetComponent<MeshBender>();
            m_Spline = GetComponent<Spline>();

            m_MeshBender.Source = SourceMesh.Build(m_Mesh).Rotate(Quaternion.Euler(m_MeshRotation)).Scale(m_MeshScale);
            m_MeshBender.Mode = MeshBender.FillingMode.StretchToInterval;
            m_MeshBender.SetInterval(m_Spline, 0, 0.01f);
            IsInitialized = true;
        }

        internal void Reset()
        {
            if (IsCurrentlyGrowing)
            {
                Debug.LogWarning("Can't reset while in growth coroutine.");
                return;
            }
            Init();
            //Contort();
        }

        internal void GrowByProgress(float timeInterval, float progressDelta)
        {
            if (IsCurrentlyGrowing)
            {
                Debug.LogWarning(
                    "Can't stack Grow commands. Wait for Growing co-routine to finish before starting a new one.");
                return;
            }

            if (progressDelta + m_GrowthProgress > 1f)
            {
                Debug.LogWarning(string.Format("Trying to grow by {0:F1}% but only {1:F1}% left in Spline. " +
                    $"Value will get clamped.", progressDelta * 100f, (1f - m_GrowthProgress) * 100f));
            }

            var targetProgress = Mathf.Clamp01(m_GrowthProgress + progressDelta);
            StartCoroutine(GrowOverTime(timeInterval, targetProgress));
        }

        // internal void GrowByDistance(float timeInterval, float growthDistance)
        // {
        //     if (IsCurrentlyGrowing)
        //     {
        //         Debug.LogError(
        //             "Can't stack Grow commands. Wait for Growing co-routine to finish before starting a new one.");
        //         return;
        //     }

        //     var targetGrowthDistance = growthDistance + CurrentGrowthDistance;
        //     if (targetGrowthDistance > m_Spline.Length)
        //     {
        //         var lengthLeft = m_Spline.Length - CurrentGrowthDistance;
        //         Debug.LogWarning($"Trying to grow {growthDistance} but only {lengthLeft} left in Spline. " +
        //             $"Value will get clamped.");
        //     }

        //     var targetProgress = Mathf.Clamp01(targetGrowthDistance / m_Spline.Length);
        //     StartCoroutine(GrowOverTime(timeInterval, targetProgress));
        // }

        IEnumerator GrowOverTime(float timeInterval, float targetProgress)
        {
            if (!IsInitialized)
            {
                Debug.LogWarning("Tried to grow before initializing. Initializing now (this may break).");
                Init();
            }
            IsCurrentlyGrowing = true;
            while (m_GrowthProgress < targetProgress)
            {
                yield return null;
                var t = Time.deltaTime / timeInterval;
                m_GrowthProgress = Mathf.Clamp(m_GrowthProgress + t, m_GrowthProgress, targetProgress);
                Contort();
            }

            IsCurrentlyGrowing = false;
        }


        void Contort()
        {
            var nodeDistance = 0f;
            var i = 0;

            foreach (var node in m_Spline.nodes)
            {
                var nodeDistanceRate = nodeDistance / m_Spline.Length;
                var nodeScale = m_StartScale * (m_GrowthProgress - nodeDistanceRate);
                node.Scale = new Vector2(nodeScale, nodeScale);

                if (i < m_Spline.curves.Count)
                {
                    nodeDistance += m_Spline.curves[i++].Length;
                }
            }

            if (m_Generated != null)
            {
                m_MeshBender.SetInterval(m_Spline, 0, m_Spline.Length * m_GrowthProgress);
                m_MeshBender.ComputeIfNeeded();
            }
        }
    }
}
